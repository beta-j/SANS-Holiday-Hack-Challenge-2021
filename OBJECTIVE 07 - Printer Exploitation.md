# OBJECTIVE 7 - Printer exploitation #

## OBJECTIVE : ##
>Investigate the stolen [Kringle Castle printer](https://printer.kringlecastle.com/). Get shell access to read the contents of `/var/spool/printer.log`. What is the name of the last file printed (with a .xlsx extension)? Find Ruby Cyster in Jack's office for help with this objective.

#  

## HINTS: ##
<details>
  <summary>Hints provided for Objective 7</summary>
  
>-	Files placed in `/app/lib/public/incoming` will be accessible under `https://printer.kringlecastle.com/incoming/`.
>-	[Hash Extension Attacks](https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks) can be super handy when there's some type of validation to be circumvented.
>-	When analyzing a device, it's always a good idea to pick apart the firmware. Sometimes these things come down **Base64-encoded**.

</details>

#  

## PROCEDURE : ##

### 3. Getting Started ###
If that last objective is anything to go by, things will start getting a lot tougher now…
For this objective we are forwarded to a printer’s web interface.  Looking around for a possible point of entry, the first thing that sticks out to me is the **“Firmware Update”** page which allows us to download the current firmware and upload new firmware to the printer – this fits perfectly with one of the hints I got from Ruby Cyster, who also hinted that we should pick apart the firmware and that it might be base-64 encoded.

Once the firmware is downloaded and I have a look inside, I see that there is a block of unreadable text which makes up the actual “firmware” portion of the file, followed by a `signature` variable which appears to be some kind of hash, a `secret_length` variable with a value of `16` and an `algorithm` variable with a value of `SHA256`.

By copying the firmware portion on its own, pasting it into [Cyberchef](https://gchq.github.io/CyberChef/) and performing a base64 decode operation, I end up with unreadable text once again, but Cyberchef conveniently gives us a hint that this might actually be a zip file and by running an unzip operation I get an uncompressed `firmware.bin` file.

![image](https://github.com/beta-j/SANS-Holiday-Hack-Challenge-2021/assets/60655500/1b220a4b-7f8a-44be-907b-18774d8485b3)

By running the file `firmware.bin` we discover that the file is an `ELF 64-bit LSB` pie executable.

Although it’s not included in the actual hints for this Objective, Ruby Cyster mentions that *“if you append multiple files of that type, the last one is processed”*.  So my plan of action at this stage is to try and write a new bin file with instructions to copy the contents of `/var/spool/printer.log` to `/app/lib/public/`, zip it and append it to the original firmware’s zip file, encode everything with base64 and figure out a way to deal with the signature.

So, I created a [simple bash script](Code/Printer_Exploit_Bash_Script.sh) that creates a directory `/app/lib/public/` (in case it doesn’t exist already) and copies `/var/spool/printer.log` to it.  I saved this file as `firmware.bin` and compressed it in a zip archive called `evil.zip`.

The printer is expecting a base64 encoded zip file with a `firmware.bin` file inside which it then executes.  So I needed to append the newly created `evil.zip` to the original `firmware.zip` to create a new zip file with a valid hash signature.  To do this I followed the hints and used the `hash_extender` tool.
```console
┌──(kali㉿kali)-[~/printer_hack]
└─$ hex evil.zip 
504b0304140000000800ce7a9653b1009938420000005b0000000c001c006669726d776172652e62696e55540900030489c361fb8fc36175780b000104e803000004e803000075cbc11180200c04c03f55e0f8f76a0274f0c69064825abf15b8ff5d17542ae699c6b533328a3b8415fe546103b5d9a0f6d43ce32d81e966020fea7dc426d67fcb07504b01021e03140000000800ce7a9653b1009938420000005b0000000c0018000000000001000000ed81000000006669726d776172652e62696e55540500030489c36175780b000104e803000004e8030000504b0506000000000100010052000000880000000000
```
```console
┌──(kali㉿kali)-[~/printer_hack]
└─$ ./hash_extender/hash_extender --file firmware.zip --secret 16 --signature 2bab052bf894ea1a255886fde202f451476faba7b941439df629fdeb1ff0dc97 --append 504b0304140000000800ce7a9653b1009938420000005b0000000c001c006669726d776172652e62696e55540900030489c361fb8fc36175780b000104e803000004e803000075cbc11180200c04c03f55e0f8f76a0274f0c69064825abf15b8ff5d17542ae699c6b533328a3b8415fe546103b5d9a0f6d43ce32d81e966020fea7dc426d67fcb07504b01021e03140000000800ce7a9653b1009938420000005b0000000c0018000000000001000000ed81000000006669726d776172652e62696e55540500030489c36175780b000104e803000004e8030000504b0506000000000100010052000000880000000000 --append-format=hex  
```

The result of the `hash_extender` operation is an ASCII hex output which I could then use to create a new file and then convert it to binary which I used to create my  new malicious zip file:
```console
$ cat output_hex | xxd -r -p > output.zip
```

To check that everything is ok, I tried unzipping the new `output.zip` file and confirmed that I got a `firmware.bin` file with [my bash script payload](Code/Printer_Exploit_Bash_Script.sh) in it.

All that remains is to encode the zip file in base64 (making sure to use the `-w 0` switch to disable line-breaks) and to craft a new JSON file with the new base64 encoded “firmware” and signature generated by `hash_extender`.
```console
$ base64 -w 0 output.zip
```

I uploaded the new zip file and was happy to see that the firmware was *“successfully uploaded and validated”* and that the package was being *“executed in the background”*.
![image](https://github.com/beta-j/SANS-Holiday-Hack-Challenge-2021/assets/60655500/c47d655c-69e6-4a70-a17a-a2fb5e296145)

Now, if my bash script worked, the printer should have placed a copy of `printer.log` in the publicly accessible directory `/app/lib/public/incoming`. And – sure enough - visiting `https://printer.kringlecastle.com/incoming/printer.log` in my browser gives me the contents of the `printer.log` file!
![image](https://github.com/beta-j/SANS-Holiday-Hack-Challenge-2021/assets/60655500/1d117bd9-9bf9-4f9c-b4ee-8d4060e78a14)




